# Unity Rules Engine for Quest VR — Final Integrated Implementation Plan (v1.2)

*A single, merged plan that keeps the best ideas from all drafts and the LLM-authoring guidance, with a curated “golden” example set.*

---

## Executive summary

Build a deterministic, zero/low-allocation Event-Condition-Action (ECA) rules engine that compiles JSON rules into tiny per-rule FSMs, runs comfortably at 72–120 Hz on Quest, and is **easy for both humans and LLMs to author correctly**. Architecture: a standalone .NET Standard 2.1 core plus a Unity adapter; author in JSON → validate/lint → compile to a compact binary pack; deterministic runtime with clear concurrency semantics, timer wheel scheduling, and a pragmatic **three-tier execution model** for hot-path spatial logic.  &#x20;

---

## Goals & success criteria

* **Perf:** p95 evaluation per fired rule ≤ **0.5 ms** on Quest 2/3; steady-state hot paths \~0 allocs.&#x20;
* **Reliability:** 60-minute soak with zero crashes; robust recovery from invalid rule packs.&#x20;
* **Scale:** Sustain 100–150 active rules at target refresh rates with headroom.&#x20;
* **DX:** Hot reload (Editor), “why didn’t it fire?” traces, linter with fix-its, deterministic replay simulator.&#x20;

---

## Architecture

### Core (.NET Standard 2.1, IL2CPP-safe)

* **Loader → Validator → Compiler:** JSON → AST → **per-rule FSM** (+ expression bytecode). Strings resolve to int IDs for entities/zones/services at build time. Output is a compact **`.uar`** pack.&#x20;
* **EventBus:** struct events in a lock-free ring buffer; pre-indexed subscriber lists.&#x20;
* **ConditionEval:** tiny typed DSL (no reflection), constant-folded at load.&#x20;
* **ActionExec:** deterministic per-rule executor with `single|restart|queue|parallel` modes and bounded concurrency.&#x20;
* **Scheduler:** **timer wheel** / calendar queue; all durations normalized to ms at compile time.&#x20;
* **Registries:** typed **EntityRegistry** (read model) and **ServiceRegistry** (validated actions + thread affinity).&#x20;

### Unity adapter

* PlayerLoop hook (Update/FixedUpdate), main-thread hop for Unity APIs, non-alloc physics + zones, Meta XR input bridge, and services (haptics, UI, audio, scene, camera, HTTP, VFX).&#x20;

### Three-tier execution model (pragmatic)

* **Tier: critical** — Burst jobs + Native Collections for dense spatial/proximity sampling; opt-in and isolated.&#x20;
* **Tier: standard** — core ECA runtime (default path).&#x20;
* **Tier: reactive** — bounded event-stream helpers for temporal patterns; either (a) custom zero-alloc operators or (b) R3/UniTask when not on hot paths; both hidden behind the same interface. &#x20;

### Threading & time

* Single-threaded engine tick; adapter marshals Unity calls to main thread; async I/O rejoins through controlled points. Single `IClock`.&#x20;

### Memory strategy

* Pre-sized pools for contexts and timers; value-type events; no LINQ/closures on hot paths; IL2CPP-friendly delegates.&#x20;

---

## Authoring model (JSON v1.2 — LLM-robust)

> This surface merges the compact schema with the LLM-reliability guidance: explicit discriminators, consistent arrays, enums instead of booleans, and units/ranges embedded in field names. Back-compat aliases: the loader accepts `triggers/conditions/actions` as synonyms for `on/if/do`. &#x20;

### Top level

```jsonc
{
  "schema_version": "1.2.0",
  "id": "string",
  "alias": "string?",
  "description": "string?",
  "mode": "single|restart|queue|parallel",
  "max_instances_1_32": 1,
  "vars": { },
  "on": [ /* Trigger[] */ ],
  "if": [ /* Condition[] */ ],
  "do": [ /* Action[] */ ],
  "capabilities": ["http","zones","haptics"]?,
  "hints": { "tier": "critical|standard|reactive", "estimated_ms": 0.10, "can_batch": true }?
}
```

### Triggers (all accept `options`)

```jsonc
"options": { "debounce_ms_min_0": 0, "throttle_ms_min_0": 0, "cooldown_ms_min_0": 0, "distinct_enum": "deep|shallow|off" }
```

```jsonc
{ "type": "event",   "name": "string", "data_match": { }, "id": "t?" }
{ "type": "state",   "entity": "string", "from": ["enum"]?, "to": ["enum"]?, "for_ms_min_0": 0, "attr": "string?", "id": "t?" }
{ "type": "numeric", "entity": "string", "above": 0.0?, "below": 0.0?, "for_ms_min_0": 0, "id": "t?" }
{ "type": "zone",    "entity": "string", "zone": "string", "event": "enter|leave", "id": "t?" }
{ "type": "time",    "at": "HH:MM:SS"?, "every": { "hours": "*/n"?, "minutes": "*/n"?, "seconds": "*/n"?, "align": "HH:MM:SS" }?, "cron": "string?" }
{ "type": "pattern", "within_ms": 300, "steps": [ { "event": { "name":"string", "data": { } } } ], "id": "t?" }
```

### Conditions

```jsonc
{ "type": "state",   "entity": "string", "is": ["enum"], "attr": "string?" }
{ "type": "numeric", "entity": "string", "above": 0.0?, "below": 0.0? }
{ "type": "time",    "after": "HH:MM:SS"?, "before": "HH:MM:SS"?, "weekday": ["mon","tue","wed","thu","fri","sat","sun"]? }
{ "type": "trigger", "id": ["t","t2"] }
{ "type": "expr",    "expr": "typed mini-DSL" }
{ "type": "and|or|not", "conditions": [ /* Condition[] */ ] }
```

### Actions

```jsonc
{ "type": "call", "service": "domain.name",
  "target": { "entity": ["string"]? },
  "data": { /* string interpolation allowed as ${...} */ } }

{ "type": "wait", "for_ms": 1000 }
{ "type": "wait", "until": { /* Condition */ }, "timeout_ms": 30000, "on_timeout": "continue|stop" }

{ "type": "choose",
  "when": [ { "if": [ /* Condition[] */ ], "do": [ /* Action[] */ ] } ],
  "else": [ /* Action[] */ ] }

{ "type": "parallel", "do": [ /* Action[] */ ] }
{ "type": "repeat", "count_1_100": 3?, "until": [ /* Condition[] */ ]?, "do": [ /* Action[] */ ] }
{ "type": "set_vars", "vars": { "k": "v" } }
{ "type": "stop", "reason": "string", "error": "no|soft|hard" }   // enum, not boolean
```

### Expressions & interpolation

Selectors: `state("entity.id")`, `attr("entity.id","name")`, `vars.*`, `trigger.id`, `trigger.data.*`, `ticks()`.
Ops: `! && || == != < <= > >=` + arithmetic; funcs: `clamp|min|max|abs`.
Interpolation **only in strings** (action `data`). &#x20;

**Why this schema?** It unifies the proven ECA + FSM surface and explicitly bakes in LLM-friendly patterns (arrays, enums, inline units, corrective errors) to lift first-pass validity.&#x20;

---

## Developer experience (DX) & tools

* **Linter** (JSON Schema + semantic checks + perf heuristics + anti-patterns).
* **Compiler CLI**: `validate → compile (.uar) → disasm → stats`.
* **Simulator**: deterministic replay from recorded traces.
* **Editor Window**: live rule states, timers/cooldowns, “why didn’t it fire?”.
* **Authoring guardrails**: consistent arrays, enum strings, inline units, **structured fix-it errors** with “Did you mean …?”. &#x20;

---

## Security & safety

Capabilities allowlist per rule pack; service argument schemas with numeric clamps + thread affinity; HTTP domain allowlist, timeouts, body caps, and secret redaction.&#x20;

---

## Testing & performance

* **Unit:** parser, DSL, timer wheel, FSM transitions.
* **Property-based:** numeric ranges, time windows, sequence matching.
* **Integration:** curated examples; determinism for each `mode`.
* **Device perf:** IL2CPP on Quest; synthetic workloads (N rules × M events/s); allocation snapshots; p95/p99 latencies. &#x20;

---

## Packaging & CI

Packages: `Rules.Core` (NuGet), `Rules.UnityAdapter` (UPM), `Rules.Tools` (CLI), `Rules.Samples`. CI: .NET tests, Unity edit/play mode, device smoke & perf baselines on PRs.&#x20;

---

## Phased delivery

**Phase 1 — Core MVP (2–3 weeks)**
AST/validation; triggers (`event|state|numeric|time|zone|pattern`), conditions, actions (`call|wait|choose|parallel|repeat|set_vars|stop`), FSM compiler, timer wheel, registries, dry-run + logs. **Gate:** unit/property tests; synthetic p95 < 0.5 ms.&#x20;

**Phase 2 — Unity adapter (2–3 weeks)**
Meta XR input; zones; services (haptics/ui/audio/scene/camera/http); Editor Window + playground; IL2CPP smoke.&#x20;

**Phase 3 — Perf & tiering (1–2 weeks)**
Pools tuning; compiled `.uar`; stress @100+ rules; soak tests; **optional Burst spatial fast-lane** for hotspots.&#x20;

**Phase 4 — Polish (as needed)**
Cron/time extras, richer diagnostics, schema migration helpers, docs & golden set.&#x20;

---

## Risks & mitigations

* **Thermal / perf spikes:** dynamic evaluation-rate caps; keep 30% headroom; promote non-critical work off hot path.&#x20;
* **LLM authoring errors:** schema conventions + progressive validation + corrective messages.&#x20;
* **IL2CPP quirks:** zero runtime codegen; explicit delegates; device tests in CI.&#x20;

---

# Curated “Golden” Example Set (v1.2 schema)

> Consistent arrays, enum strings, and inline units. Interpolation only inside action `data` strings.

### 1) App start → log (minimal)

```json
{
  "schema_version": "1.2.0",
  "id": "app_start_log",
  "mode": "single",
  "on": [ { "type": "event", "name": "app.started", "id": "start" } ],
  "do": [
    { "type": "call", "service": "log.info",
      "data": { "message": "Application started at ${ticks()} ms" } }
  ]
}
```

### 2) Right button press → haptic tap (cooldown)

```json
{
  "schema_version": "1.2.0",
  "id": "xr_button_haptic",
  "mode": "single",
  "on": [
    { "type": "state", "entity": "xr.controller.right.button_primary",
      "to": ["pressed"], "id": "press",
      "options": { "distinct_enum": "deep", "cooldown_ms_min_0": 50 } }
  ],
  "if": [ { "type": "state", "entity": "game.mode", "is": ["playing","paused"] } ],
  "do": [
    { "type": "call", "service": "haptics.pulse",
      "data": { "hand": "right", "amplitude_0_to_1": 0.5, "duration_ms": 50 } }
  ],
  "capabilities": ["haptics"]
}
```

### 3) Long press-and-release → haptic pattern

```json
{
  "schema_version": "1.2.0",
  "id": "xr_button_long_release",
  "mode": "single",
  "on": [
    { "type": "state", "entity": "xr.controller.right.button_primary",
      "to": ["released"], "for_ms_min_0": 2000, "id": "long_release" }
  ],
  "do": [
    { "type": "call", "service": "haptics.pattern",
      "data": { "hand": "right", "pattern": "double_click" } }
  ],
  "capabilities": ["haptics"]
}
```

### 4) Zone enter/leave → torch + exposure (choose + parallel)

```json
{
  "schema_version": "1.2.0",
  "id": "zone_lighting",
  "mode": "restart",
  "on": [
    { "type": "zone", "entity": "player.avatar", "zone": "dark_cave", "event": "enter", "id": "enter" },
    { "type": "zone", "entity": "player.avatar", "zone": "dark_cave", "event": "leave", "id": "leave" }
  ],
  "do": [
    { "type": "choose",
      "when": [
        { "if": [ { "type":"trigger", "id": ["enter"] } ],
          "do": [
            { "type": "parallel", "do": [
              { "type": "call", "service": "light.turn_on",
                "target": { "entity": ["light.player_torch"] },
                "data": { "brightness_0_255": 255, "transition_ms": 2000 } },
              { "type": "call", "service": "audio.play", "data": { "sound": "torch_ignite", "volume_0_to_1": 0.7 } },
              { "type": "call", "service": "camera.set_exposure", "data": { "exposure": 1.5, "adaptation_ms": 3000 } }
            ] }
          ] },
        { "if": [ { "type":"trigger", "id": ["leave"] } ],
          "do": [
            { "type": "call", "service": "light.turn_off",
              "target": { "entity": ["light.player_torch"] },
              "data": { "transition_ms": 1000 } },
            { "type": "call", "service": "camera.set_exposure", "data": { "exposure": 1.0, "adaptation_ms": 2000 } }
          ] }
      ] }
  ],
  "capabilities": ["zones"]
}
```

### 5) Low-health loop → repeat-until recovery (VFX/SFX/haptics)

```json
{
  "schema_version": "1.2.0",
  "id": "combat_low_health",
  "mode": "single",
  "on": [ { "type": "numeric", "entity": "player.health", "below": 30, "id": "critical" } ],
  "if": [
    { "type": "state", "entity": "player.status", "is": ["alive"] },
    { "type": "not", "conditions": [ { "type": "state", "entity": "game.mode", "is": ["cutscene"] } ] }
  ],
  "do": [
    { "type": "repeat",
      "until": [ { "type": "numeric", "entity": "player.health", "above": 29 } ],
      "do": [
        { "type": "parallel", "do": [
          { "type": "call", "service": "haptics.pulse", "data": { "hand": "both", "amplitude_0_to_1": 0.8, "duration_ms": 200 } },
          { "type": "call", "service": "vfx.screen_effect", "data": { "effect": "blood_vignette", "intensity_0_to_1": 0.7 } },
          { "type": "call", "service": "audio.play", "data": { "sound": "heartbeat_fast", "volume_0_to_1": 0.9 } }
        ] },
        { "type": "wait", "for_ms": 1000 }
      ]
    }
  ],
  "capabilities": ["haptics"]
}
```

### 6) Every 5 min → telemetry (conditional stop)

```json
{
  "schema_version": "1.2.0",
  "id": "telemetry_5min",
  "mode": "single",
  "on": [ { "type": "time", "every": { "minutes": "*/5", "align": "00:00:00" }, "id": "tick" } ],
  "do": [
    { "type": "choose",
      "when": [
        { "if": [ { "type":"expr", "expr":"state('sensor.active_players') == 0" } ],
          "do": [
            { "type": "call", "service": "log.debug", "data": { "message": "No active players, skipping telemetry" } },
            { "type": "stop", "reason": "No active players", "error": "no" }
          ] }
      ],
      "else": [
        { "type": "call", "service": "http.post",
          "data": {
            "url": "https://telemetry.example/ingest",
            "json": {
              "ts_ms": "${ticks()}",
              "players": "${state('sensor.active_players')}",
              "fps": "${state('sensor.average_fps')}",
              "mem_mb": "${state('sensor.memory_usage')}",
              "scene": "${state('game.current_scene')}"
            },
            "timeout_ms": 10000
          } }
      ]
    }
  ],
  "capabilities": ["http"]
}
```

### 7) Quest event → wait for zone → load scene

```json
{
  "schema_version": "1.2.0",
  "id": "quest_handler",
  "mode": "parallel",
  "max_instances_1_32": 5,
  "on": [ { "type": "event", "name": "quest.objective_complete", "id": "q" } ],
  "do": [
    { "type": "choose",
      "when": [
        { "if": [ { "type":"expr", "expr":"trigger.data.quest_id == 'ancient_artifact' && trigger.data.objective_id == 'collect_fragments'" } ],
          "do": [
            { "type": "call", "service": "ui.show_notification",
              "data": { "title": "Fragments Collected", "message": "You have all three fragments!", "duration_ms": 5000 } },
            { "type": "call", "service": "object.spawn",
              "data": { "prefab": "ancient_portal", "position": "${state('marker.temple_entrance')}", "activate_after_ms": 2000 } },
            { "type": "wait",
              "until": { "type": "expr", "expr": "state('zone.temple_entrance.occupancy') > 0" },
              "timeout_ms": 600000, "on_timeout": "stop" },
            { "type": "call", "service": "scene.load", "data": { "scene": "ancient_temple_interior", "transition": "fade_to_black" } }
          ] }
      ],
      "else": []
    }
  ]
}
```

### 8) Auto performance reduction until FPS recovers

```json
{
  "schema_version": "1.2.0",
  "id": "perf_optimizer",
  "mode": "single",
  "vars": { "min_fps": 30 },
  "on": [ { "type": "numeric", "entity": "sensor.current_fps", "below": 30, "for_ms_min_0": 5000, "id": "low_fps" } ],
  "if": [ { "type": "state", "entity": "settings.auto_performance", "is": ["enabled"] } ],
  "do": [
    { "type": "call", "service": "log.warning", "data": { "message": "FPS < ${vars.min_fps} for 5s, optimizing..." } },
    { "type": "repeat",
      "until": [ { "type": "or", "conditions": [
        { "type": "numeric", "entity": "sensor.current_fps", "above": 45 },
        { "type": "state",   "entity": "graphics.quality", "is": ["very_low"] }
      ] } ],
      "do": [
        { "type": "call", "service": "graphics.reduce_quality", "data": { "step_1_3": 1 } },
        { "type": "wait", "for_ms": 2000 },
        { "type": "call", "service": "log.info",
          "data": { "message": "Quality=${state('graphics.quality')} FPS=${state('sensor.current_fps')}" } }
      ]
    }
  ]
}
```

### 9) Weekday 08:00 summary

```json
{
  "schema_version": "1.2.0",
  "id": "weekday_daily_summary",
  "mode": "single",
  "on": [ { "type": "time", "at": "08:00:00", "id": "morning" } ],
  "if": [ { "type": "time", "weekday": ["mon","tue","wed","thu","fri"] } ],
  "do": [
    { "type": "call", "service": "log.info",
      "data": { "message": "Weekday summary at ${ticks()} ms" } }
  ]
}
```

### 10) Wait with timeout → fallback hint

```json
{
  "schema_version": "1.2.0",
  "id": "portal_wait_then_hint",
  "mode": "single",
  "on": [ { "type": "event", "name": "portal.spawned", "id": "spawn" } ],
  "do": [
    { "type": "wait",
      "until": { "type": "expr", "expr": "state('distance.player_to_portal') < 2.0" },
      "timeout_ms": 30000, "on_timeout": "continue" },
    { "type": "choose",
      "when": [
        { "if": [ { "type": "expr", "expr": "state('distance.player_to_portal') < 2.0" } ],
          "do": [ { "type": "call", "service": "ui.show_notification", "data": { "message": "Portal engaged!", "duration_ms": 2000 } } ] }
      ],
      "else": [
        { "type": "call", "service": "ui.show_notification",
          "data": { "message": "Move closer to the portal to enter.", "duration_ms": 4000 } }
      ]
    }
  ]
}
```

### 11) Gesture pattern: double-tap within 300 ms

```json
{
  "schema_version": "1.2.0",
  "id": "double_tap_action",
  "mode": "single",
  "on": [
    { "type": "pattern", "within_ms": 300, "id": "double_tap",
      "steps": [
        { "event": { "name":"xr.button", "data": { "hand":"right", "btn":"primary", "state":"pressed" } } },
        { "event": { "name":"xr.button", "data": { "hand":"right", "btn":"primary", "state":"pressed" } } }
      ] }
  ],
  "do": [
    { "type": "call", "service": "ui.show_notification", "data": { "message": "Double tap!", "duration_ms": 1500 } },
    { "type": "call", "service": "haptics.pattern", "data": { "hand":"right", "pattern":"double_click" } }
  ],
  "capabilities": ["haptics"]
}
```

### 12) Contextual grab (gesture + raycast + haptics preview; tier hint)

```json
{
  "schema_version": "1.2.0",
  "id": "context_grab",
  "mode": "single",
  "hints": { "tier": "critical" },
  "on": [
    { "type": "event", "name": "xr.gesture", "data_match": { "gesture": "pinch", "confidence": 0.8 }, "id": "pinch" }
  ],
  "if": [
    { "type": "expr", "expr": "state('raycast.hit') == true && state('raycast.layer') == 'grabbable' && state('player.hands_free') == true" }
  ],
  "do": [
    { "type": "call", "service": "object.attach_to_hand", "data": { "hand": "trigger_hand", "method": "physics_joint" } },
    { "type": "call", "service": "haptics.pulse", "data": { "hand": "trigger_hand", "amplitude_0_to_1": 0.6, "duration_ms": 30 } },
    { "type": "call", "service": "audio.spatial", "data": { "sound": "grab_success", "position": "${state('object.position')}" } }
  ],
  "capabilities": ["haptics","zones"]
}
```

---

## Why this merges the “best of” the documents

* **FSM-compiled ECA core + `.uar` packs + timer wheel** for determinism and performance. &#x20;
* **Three-tier execution** with optional Burst fast-lane for spatial hotspots, while keeping standard ECA clean and deterministic.&#x20;
* **LLM-robust schema patterns** (explicit discriminators, arrays, enums not booleans, inline units), plus structured, corrective validation.&#x20;
* **Unity adapter** with clear thread-affinity and service allow-lists for safe, predictable side effects.&#x20;

---

If you want next steps, I can:

1. emit a strict JSON Schema for v1.2, 2) scaffold the `Rules.Core/UnityAdapter/Tools/Samples` repo (IL2CPP-ready), and 3) spin up a minimal Editor window + CLI (`uarc`, `uarsim`) aligned to this plan.
